<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../favicon.ico">

    <title>Tutorial1</title>

    <!-- Bootstrap core CSS -->
    <link href="../../dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="navbar-fixed-top.css" rel="stylesheet">

    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <script src="../../assets/js/ie-emulation-modes-warning.js"></script>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Gelly</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="./home.html">Home</a></li>
            <li><a href="https://github.com/apache/flink/tree/master/flink-staging/flink-gelly" title="Gelly's SourceCode">GitHub</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Tutorials<span class="caret"></span></a>
              <ul class="dropdown-menu">
			  	<li><a href="./tutorial0.html" title="Introduction to Gelly">Tutorial0</a></li>
				<li><a href="./tutorial1.html" title="Load public data and create a graph and run a library method">Tutorial1</a></li>
				<li><a href="./tutorial2.html" title="Know your graph">Tutorial2</a></li>
				<li><a href="./tutorial3.html" title="Simple transformations">Tutorial3</a></li>
				<li><a href="./tutorial4.html" title="Advanced transofrmations">Tutorial4</a></li>
				<li><a href="./tutorial5.html" title="Neighborhood methods">Tutorial5</a></li>
				<li><a href="./tutorial6.html" title="Implement a graph validator">Tutorial6</a></li>
				<li><a href="./tutorial7.html" title="Vertex-centric iterations">Tutorial7</a></li>
				<li><a href="./tutorial8.html" title="Gather-sum-apply iterations">Tutorial8</a></li>
              </ul>
            </li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>


    <!-- Begin page content -->
    <div class="container">
      <div class="page-header">
        <h1>Load public data, create a graph and run a library method</h1>
      </div>
			<h3>Here comes Gelly</h3>
			<p>We start delving into Gelly by focusing on the following three concepts in this tutorial:
			basics of a Gelly-Graph, reading input data set and Graph creation using the different available methods. We will
			finish by showing how to run a library method on our Graph.					
			<h4>Some Basics</h4>
			<p>
				In Gelly, a Graph is represented by a DataSet of vertices and a
				DataSet of edges. Graph nodes are represented by the <em>Vertex</em>
				type. A Vertex is defined by a unique ID and an optional value.
				Vertices without value can be represented by setting the value type to NullValue.
				Graph edges are represented by the <em>Edge</em> type. An Edge is defined
				by a source ID (the ID of the source Vertex), a target ID (the ID of
				the target Vertex) and an optional value. The source and target IDs
				should be of the same type as the Vertex IDs. Edges with no value
				have a NullValue value type. For example, let's create two arbitrary vertices 
				and an edge connecting them:
			</p><br>
			<p><code>Vertex&lt;Long, String&gt; v1 = new Vertex&lt;Long, String&gt;(1L, &quot;foo&quot;);<br>
                     Vertex&lt;Long, String&gt; v2 = new Vertex&lt;Long, String&gt;(2L, &quot;goo&quot;);<br>
                     Edge&lt;Long, Double&gt; e = new Edge&lt;Long, Double&gt;(1L, 2L, 0.5);</code></p><br>
			<p>
			So we have created two vertices v1 and v2 with Long IDs '1L' and '2L' and String values
			"foo" and "goo" respectively, connected by an Edge with Double value of 0.5.
			Once we have our complete data set of edges and vertices, a Graph can be defined
			by passing them as parameters to the graph creation methods, as we will see next.<br> 
			The first attribute of a Gelly-Graph is the type for 
			Vertex/Edge ID, the second is the value type for vertices,
		    followed by the value type for edges. For example, the definition of our Graph representing the
			two vertices (v1,v2) and Edge (e), would be:</p>
			<p>
				<img src="./images/graphRep.jpg"/>
			</p>
		

			<h4>Reading input data and Graph creation</h4>	
            <p>Now that we know the fundamental blocks of a graph, we will see how to create one starting from 
			a real data set.</p>			
				<ol>
				<li>Read data from input file as a DataSet of Edges, DataSet of Tuple3 or as a Collection.</li>
                <li>Depending on the choice in step one, use the appropriate graph creation method:</li>
                </ol>
	    <br>
		<p><code>Graph.fromDataSet(vertices, edges, env);<br>
         Graph.fromTupleDataSet(vertexTuples, edgeTuples, env);<br>
         Graph.fromCollection(vertexList, edgeList, env);
        </code></p><br>

			<p>
				For practising, you can start with any publicly available
				graph data set (e.g. SNAP or Konnect) to read a file of edges,
				create and initialize a Gelly-Graph. For our tutorials, we are going
				to use the &quot;<em><a
					href="http://konect.uni-koblenz.de/networks/ego-twitter">twitter
						list</a></em>&quot; data set from Konnect, where a node represent a user
				and an edge the &quot;follow relation&quot; among users. We will see how three different 
				graph creation methods can be used starting from this twitter data set. The purpose is to show the different 
				approaches that can be adopted depending on whether you are given a data set of edges, tuples or a collection.<br><br>
				
				In the sample data set that we have used for these examples, the user is given as
				input only information regarding edges. However, if in your input data, vertices'
				information is also present, then an approach similar to the 
				one used for parsing the edges-file can be used for vertices as well.
				The optional DataSet of vertices can be passed as first parameter to the Graph creation methods. If no
				vertex input is provided, then during graph creation, Gelly will
				automatically produce the Vertex DataSet from edges input. In
				this case, vertices will have no values. Alternatively, as we will
				see in the example below, even if vertex input data set is missing, 
				you can provide an ad-hoc <em>MapFunction</em> to initialize vertex values. <br>


			</p><br>
			<p>
				<strong style="color: #002182"><em>fromDataSet:</em></strong> method used to create a Graph 
				from a DataSet of edges and an optional DataSet of vertices
			</p>
			<pre><code>ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();
			
	    <em style="color:green">//get the DataSet of edges. Edges in our example have no values</em>
            DataSet&lt;Edge&lt;Long, NullValue&gt;&gt; links = getLinksDataSet(env);

	    <em style="color:green">//use the edges DataSet to create a Graph</em>
            Graph&lt;Long, Double, NullValue&gt; graph = Graph.fromDataSet(links, new MapFunction&lt;Long, Double&gt;() {

                <em style="color:green">//mapping function to initialize vertex values to 1.0</em>
                public Double map(Long value) throws Exception {
                    return 1.0;
                }
            }, env);



        @SuppressWarnings(&quot;serial&quot;)
        private static DataSet&lt;Edge&lt;Long, NullValue&gt;&gt; getLinksDataSet(
                ExecutionEnvironment env) {

        <em style="color:green">//Input data format: &lt;srcEdgeId&gt;\t&lt;targetEdgeId&gt;\n
        //Since the output has to be a data set of edges while a Tuple2 has been read from the CSV file,
	//a mapper is used to create an edge from a Tuple2, with edge values set to null</em>
                return env.readCsvFile(edgeInputPath)
                        .fieldDelimiter(&quot; &quot;)
                        .lineDelimiter(&quot;\n&quot;)
                        .types(Long.class, Long.class)
                        .map(new MapFunction&lt;Tuple2&lt;Long, Long&gt;, Edge&lt;Long, NullValue&gt;&gt;() {
                            public Edge&lt;Long, NullValue&gt; map(Tuple2&lt;Long, Long&gt; value) {
                                return new Edge&lt;Long, NullValue&gt;(value.f0, value.f1,
                                        NullValue.getInstance());
                                }
                            });
        }
        </code>
			</pre>
		<p>	
        To use this method, we used a mapper to convert a Tuple2 to an Edge. However, if you have as input a Tuple3, then you can create
		edges with values as follows:</p>
		
		<pre><code>
        private static DataSet&lt;Edge&lt;Long, Double&gt;&gt; getLinksDataSet(
                ExecutionEnvironment env) {

        <em style="color:green">//in case your input is of type: &lt;srcEdgeId&gt;\t&lt;targetEdgeId&gt;\t&lt;EdgeValue&gt;\n,</em>
                return env.readCsvFile(edgeInputPath)
                        .fieldDelimiter(&quot; &quot;)
                        .lineDelimiter(&quot;\n&quot;)
                        .types(Long.class, Long.class, Double.class)
                        .map(new Tuple3ToEdgeMap&lt;Long, Double&gt;());
                }
        }
        </code>
			</pre><br>
		
		
			<p>
				<strong style="color: #002182"><em>fromTupleDataSet:</em></strong> from a DataSet of Tuple3 and an optional DataSet of Tuple2. In this case, Gelly will convert each Tuple3 to an Edge, where the first field will be the source ID, the second field will be the target ID and the third field will be the edge value. Equivalently, each Tuple2 will be converted to a Vertex, where the first field will be the vertex ID and the second field will be the vertex value.<br>
				From our sample input we can retrieve only a Tuple2 as no edge values have been provided. In order to use this method of Graph creation 
				which requires a Tuple3 to create edges, we use a mapper function to convert a Tuple2 to a Tuple3.
			</p>
			<pre>           <code><em style="color:green">//read a DataSet of Tuple2</em>
	    DataSet&lt;Tuple2&lt;Long, Long&gt;&gt; edgeTuples = env.readCsvFile(args[0])
                    .fieldDelimiter(&quot; &quot;)
                    .lineDelimiter(&quot;\n&quot;)
                    .types(Long.class, Long.class);

            <em style="color:green">
            //This Graph creation method takes as input edges as a Tuple3 DataSet.
            //In case, input is a Tuple2 use a mapper function to initializes edge values:</em>
            Graph&lt;Long, NullValue, NullValue&gt; graph2 = Graph.fromTupleDataSet(edgeTuples
                    .map(new MapFunction&lt;Tuple2&lt;Long, Long&gt;, Tuple3&lt;Long, Long, NullValue&gt;&gt;() {
                        public Tuple3&lt;Long, Long, NullValue&gt; map(Tuple2&lt;Long, Long&gt; input) {
                            return new Tuple3&lt;Long, Long, NullValue&gt;(input.f0, input.f1, null);
                        }
                    }), env);
        </code>
			</pre>

			<p>
				<strong style="color: #002182"><em>fromCollection:</em></strong> from a Collection of edges and an optional Collection of vertices.<br>Just to show that a Graph can be created also from a Collection of edges, collect() has been called to obtain a List of edges from the Edge DataSet
				obtained as in case 1.
			</p>
			<pre>           <code><em style="color:green">//getLinksDataSet() method is the same as for method 1</em>
            List&lt;Edge&lt;Long, NullValue&gt;&gt; edgeList = getLinksDataSet(env).collect();
            Graph&lt;Long, NullValue, NullValue&gt; graph3 = Graph.fromCollection(edgeList, env);
        </code>
			</pre>

			<br>
			<h4>Running a library method</h4><p><img src="./images/running.jpg" align="right"/></p>
			<p>
			Gelly provides a collection of graph algorithms for easily analyzing large-scale Graphs. 
			The library methods can be used by simply calling the run() method on the input graph. For example, 
			to execute the PageRank Algorithm on our graph we call the run method as follows: 
<p><code>    DataSet&lt;Vertex&lt;Long, Double&gt;&gt; pageRanks = graph.run(
            new PageRankAlgorithm&lt;Long&gt;(DAMPENING_FACTOR, maxIterations)).getVertices();
</code></p>
            The result is a DataSet of vertices where each Vertex ID is associated with its PageRank.
			Here, the purpose is just to show  how to call a library method so we are ignoring the details
			regarding the algorithm. We will talk about it again, in a detailed manner, in the following more advanced tutorials.		
			</p>
			<br>
			<h4>It was that easy</h4>
			<p>
				We have learnt how to create a Graph in Gelly from virtually any sort
				of input data set. In the next tutorial, we will get to know some
				details regarding the Graph we have just created. </p><br>

	<p><h4><a style="margin-left: 100px" href="./tutorial0.html"><em><--Previous</em></a> <a style="margin-left: 650px" href="./tutorial2.html"><em>Next--></em></a></h4></p>
	<br><br>
    </div> <!-- /container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="../../dist/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../../assets/js/ie10-viewport-bug-workaround.js"></script>
  </body>
</html>
