<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../favicon.ico">

    <title>Tutorial8</title>

    <!-- Bootstrap core CSS -->
    <link href="../../dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="navbar-fixed-top.css" rel="stylesheet">

    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <script src="../../assets/js/ie-emulation-modes-warning.js"></script>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Gelly</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="./home.html">Home</a></li>
            <li><a href="https://github.com/apache/flink/tree/master/flink-staging/flink-gelly" title="Gelly's SourceCode">GitHub</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Tutorials<span class="caret"></span></a>
              <ul class="dropdown-menu">
			  	<li><a href="./tutorial0.html" title="Introduction to Gelly">Tutorial0</a></li>
				<li><a href="./tutorial1.html" title="Load public data and create a graph and run a library method">Tutorial1</a></li>
				<li><a href="./tutorial2.html" title="Know your graph">Tutorial2</a></li>
				<li><a href="./tutorial3.html" title="Simple transformations">Tutorial3</a></li>
				<li><a href="./tutorial4.html" title="Advanced transofrmations">Tutorial4</a></li>
				<li><a href="./tutorial5.html" title="Neighborhood methods">Tutorial5</a></li>
				<li><a href="./tutorial6.html" title="Implement a graph validator">Tutorial6</a></li>
				<li><a href="./tutorial7.html" title="Vertex-centric iterations">Tutorial7</a></li>
				<li><a href="./tutorial8.html" title="Gather-sum-apply iterations">Tutorial8</a></li>
              </ul>
            </li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>


    <!-- Begin page content -->
    <div class="container">
      <div class="page-header">
        <h1>Iterative Graph Processing</h1>
      </div>
<h2>Gather-sum-apply iterations</h2>
<p>We proceed with our discussion of iterative processing in Gelly. Like in the vertex-centric model, Gather-Sum-Apply also proceeds in synchronized iterative steps, called supersteps. Each <em>superstep</em> consists of the following three phases:</p>
<ol>
<li>Gather: a user-defined function is invoked in parallel on the edges and neighbors of each vertex, producing a partial value.</li>
<li>Sum: the partial values produced in the Gather phase are aggregated to a single value, using a user-defined reducer.</li>
<li>Apply: each vertex value is updated by applying a function on the current value and the aggregated value produced by the Sum phase.</li>
</ol>
<p>Let us consider again computing <em>PageRank</em> but this time with GSA. During the Gather phase, we calculate the partial rank to be distributed to the neighbor. In Sum, the candidate ranks are grouped by vertex ID and these partial values are summed together. In Apply, the rank value is updated by computing a new one using the dampening formula.</p><br>
<p><img src="./images/iter2.jpg"/></p>
<pre><code>    // Execute the GSA iteration
    Graph&lt;Long, Double, Double&gt; result = graph
            .runGatherSumApplyIteration(new GatherRanks(numberOfVertices), new SumRanks(),
                    new UpdateRanks(numberOfVertices), maxIterations);


@SuppressWarnings(&quot;serial&quot;)
private static final class GatherRanks extends GatherFunction&lt;Double, Double, Double&gt; {

    long numberOfVertices;

    public GatherRanks(long numberOfVertices) {
        this.numberOfVertices = numberOfVertices;
    }

    @Override
    public Double gather(Neighbor&lt;Double, Double&gt; neighbor) {
        double neighborRank = neighbor.getNeighborValue();

        if(getSuperstepNumber() == 1) {
            neighborRank = 1.0 / numberOfVertices;
        }

        return neighborRank * neighbor.getEdgeValue();
    }
}

@SuppressWarnings(&quot;serial&quot;)
private static final class SumRanks extends SumFunction&lt;Double, Double, Double&gt; {

    @Override
    public Double sum(Double newValue, Double currentValue) {
        return newValue + currentValue;
    }
}

@SuppressWarnings(&quot;serial&quot;)
private static final class UpdateRanks extends ApplyFunction&lt;Long, Double, Double&gt; {

    long numberOfVertices;

    public UpdateRanks(long numberOfVertices) {
        this.numberOfVertices = numberOfVertices;
    }

    @Override
    public void apply(Double rankSum, Double currentValue) {
        setResult((1-DAMPENING_FACTOR)/numberOfVertices + DAMPENING_FACTOR * rankSum);
    }
}
</code></pre>
<br>
<p>So we can achieve the same results but with a different approach. You can also try running the PageRankAlgorithm on the twitter data set using both the approaches. For a complete overview, have a look at the full implementation of the above <a href="https://github.com/apache/flink/blob/master/flink-staging/flink-gelly/src/main/java/org/apache/flink/graph/example/GSAPageRank.java">GSAPageRank</a>.</p>
<br>
<h4>Configuring a Gather-Sum-Apply Iteration</h4>
<p>As we saw for the Vertex-centric model, a GSA iteration can also be configured using a <strong><em>GSAConfiguration</em></strong> object. Currently, the following parameters can be specified:<em>Name, Parallelism, Solution set in unmanaged memory, Aggregators, Broadcast Variables, Number of Vertices, Neighbor Direction.</em><br>You can find more details regarding these parameters at this <a href="https://ci.apache.org/projects/flink/flink-docs-master/libs/gelly_guide.html#configuring-a-gather-sum-apply-iteration">link</a>.</p> 
<p>In the vertex-centric approach we saw how to use the number of vertices option, so let's look at it again but this time for the GSA iterations.</p>
<pre><code>Graph&lt;Long, Double, Double&gt; graph = ...

<em style="color:green">// configure the iteration</em>
GSAConfiguration parameters = new GSAConfiguration();

<em style="color:green">// set the number of vertices option to true</em>
parameters.setOptNumVertices(true);

<em style="color:green">// run the gather-sum-apply iteration, also passing the configuration parameters</em>
Graph&lt;Long, Long, Long&gt; result = graph.runGatherSumApplyIteration(
            new Gather(), new Sum(), new Apply(),
            maxIterations, parameters);

// user-defined functions
public static final class Gather {
...
// get the number of vertices
long numVertices = getNumberOfVertices();
...
}

public static final class Sum {
...
// get the number of vertices
long numVertices = getNumberOfVertices();
...
}

public static final class Apply {
...
// get the number of vertices
long numVertices = getNumberOfVertices();
...
}
</code></pre>

As you can see, also in this case <em>getNumberOfVertices()</em> can be called in all the phases of the superstep.
<p></p>
<p><img src="./images/compare.jpg" align="right"/></p>
<h3>Which model to use??</h3>
<h4>Vertex-centric vs GSA</h4>
<p>By now you would have realized that Gather-Sum-Apply iterations are quite similar to vertex-centric iterations. In fact, <strong>any algorithm which can be expressed as a GSA iteration can also be written in the vertex-centric model</strong>. The messaging phase of the vertex-centric model is equivalent to the Gather and Sum steps of GSA: Gather can be seen as the phase where the messages are produced and Sum as the phase where they are routed to the target vertex. Similarly, the value update phase corresponds to the Apply step.</p>
<p>The main difference between the two implementations are: <ul>
<li>Gather phase of GSA parallelizes the computation over the edges, while the messaging phase distributes the computation over the vertices.</li>
<li>Vertex-centric implementation uses a coGroup operator internally, while GSA uses a reduce.</li>
<li>GSA works strictly on neighborhoods, while in the vertex-centric model, a vertex can send a message to any vertex, given that it knows its vertex ID.</li>
<li>In the vertex-centric implementation, one can choose the messaging direction.</li></ul>
For a detailed explanation regarding the differences, read <a href="https://ci.apache.org/projects/flink/flink-docs-master/libs/gelly_guide.html#vertex-centric-and-gsa-comparison">here</a>.</p><br>
<p>Finally, we have a complete picture of the iterative models in Gelly. Choose the one most suitable for you and have fun &quot;<em>Gellifying</em>&quot; your iterations! </p>

<p><a style="margin-left: 100px" href="./tutorial7.html"><em>Prev</em></a></p><br><br>
    </div> <!-- /container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="../../dist/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../../assets/js/ie10-viewport-bug-workaround.js"></script>
  </body>
</html>
