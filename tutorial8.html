<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="./favicon.ico">

    <title>Tutorial8</title>

    <!-- Bootstrap core CSS -->
    <link href="./dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="navbar-fixed-top.css" rel="stylesheet">

    <script src="./assets/js/ie-emulation-modes-warning.js"></script>

  </head>

  <body>

<!-- Fixed navbar -->
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="./index.html">Gellyschool</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Tutorials<span class="caret"></span></a>
              <ul class="dropdown-menu">
                                <li><a href="./tutorial0.html">Tutorial#0: Graphs 101</a></li>
                                <li><a href="./tutorial1.html">Tutorial#1: Create a Graph and run a Gelly library method</a></li>
                                <li><a href="./tutorial2.html">Tutorial#2: Know your Graph</a></li>
                                <li><a href="./tutorial3.html">Tutorial#3: Simple transformations</a></li>
                                <li><a href="./tutorial4.html">Tutorial#4: Advanced transformations</a></li>
                                <li><a href="./tutorial5.html">Tutorial#5: Neighborhood methods</a></li>
                                <li><a href="./tutorial6.html">Tutorial#6: Graph validation</a></li>
                                <li><a href="./tutorial7.html">Tutorial#7: Vertex-centric iterations</a></li>
                                <li><a href="./tutorial8.html">Tutorial#8: Gather-sum-apply iterations</a></li>              
		</ul>
            </li>
            <li><a href="https://github.com/vasia/gelly-school">Solutions</a></li>
            <li><a href="https://ci.apache.org/projects/flink/flink-docs-master/libs/gelly_guide.html">Gelly Docs</a></li>
            <li><a href="./library.html" title="Gelly's Library Methods">Library Methods</a></li>
            <li><a href="./about.html">About</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <!-- Begin page content -->
    <div class="container">
      <div class="page-header">
        <h1>Iterative Graph Processing</h1>
      </div>
<h2>Gather-sum-apply iterations</h2>
<p>We proceed with our discussion of iterative processing in Gelly. Like in the vertex-centric model, Gather-Sum-Apply also proceeds in synchronized iterative steps, called supersteps. The three functions that need to be implemented for each superstep are:
<ul>
<li><strong>GatherFunction:</strong> this function is invoked in parallel on the edges and neighbors of each vertex and it produces a partial value.</li>
<li><strong>SumFunction:</strong> reducer that aggregates the partial values produced in the Gather phase to a single value</li>
<li><strong>ApplyFunction:</strong> it updates the Vertex value based on the current value and the aggregated value produced by the Sum phase.</li>
</ul><br>
<p>Let us consider again computing <a href="https://en.wikipedia.org/wiki/PageRank">PageRank</a> but this time with GSA.
<ol>
<li><strong>Gather phase:</strong> we calculate the partial rank to be distributed to the neighbor.</li><br>
<pre><code>
@SuppressWarnings(&quot;serial&quot;)
private static final class GatherRanks extends <strong>GatherFunction</strong>&lt;Double, Double, Double&gt; {

    long numberOfVertices;

    public GatherRanks(long numberOfVertices) {
        this.numberOfVertices = numberOfVertices;
    }

    @Override
    public Double <em style="color:blue">gather</em>(Neighbor&lt;Double, Double&gt; neighbor) {
        double neighborRank = neighbor.getNeighborValue();

        if(getSuperstepNumber() == 1) {
            neighborRank = 1.0 / numberOfVertices;
        }

        return neighborRank * neighbor.getEdgeValue();
    }
}
</pre></code><br>
<li><strong>Sum phase:</strong> candidate ranks are grouped by vertex ID and these partial values are summed together.</li><br>
<pre><code>private static final class SumRanks extends <strong>SumFunction</strong>&lt;Double, Double, Double&gt; {

    @Override
    public Double <em style="color:blue">sum</em>(Double newValue, Double currentValue) {
        return newValue + currentValue;
    }
}
</pre></code><br>
<li><strong>Apply phase:</strong> the rank value is updated by computing a new one using the dampening formula.</li><br>
<pre><code>
private static final class UpdateRanks extends <strong>ApplyFunction</strong>&lt;Long, Double, Double&gt; {

    long numberOfVertices;

    public UpdateRanks(long numberOfVertices) {
        this.numberOfVertices = numberOfVertices;
    }

    @Override
    public void <em style="color:blue">apply</em>(Double rankSum, Double currentValue) {
        setResult((1-DAMPENING_FACTOR)/numberOfVertices + DAMPENING_FACTOR * rankSum);
    }
}
</code></pre>
</ol></p><br>
<p><img src="./images/iter2.jpg"/></p>
<br>
<p>So we can achieve the same results but with a different approach. You can also try running the PageRank algorithm on the twitter data set using both the approaches. For a complete overview, have a look at the full implementation of the above <a href="https://github.com/apache/flink/blob/master/flink-staging/flink-gelly/src/main/java/org/apache/flink/graph/example/GSAPageRank.java">GSAPageRank</a>.</p>
<br>
<h4>Configuring a Gather-Sum-Apply Iteration</h4>
<p>As we saw for the Vertex-centric model, a GSA iteration can also be configured using a <strong><em>GSAConfiguration</em></strong> object. In the vertex-centric approach we saw how to use the number of vertices option, so let's look at it again but this time for the GSA iterations.</p>
<pre><code><em style="color:green">// configure the iteration</em>
GSAConfiguration parameters = new GSAConfiguration();

<em style="color:green">// set the number of vertices option to true</em>
parameters.<em style="color:blue">setOptNumVertices</em>(true);

<em style="color:green">// run the gather-sum-apply iteration, also passing the configuration parameters</em>
Graph&lt;Long, Long, Long&gt; result = graph.<em style="color:blue">runGatherSumApplyIteration</em>(
            new Gather(), new Sum(), new Apply(),
            maxIterations, parameters);

// user-defined functions
public static final class <em style="color:blue">Gather</em> {
...
// get the number of vertices
long numVertices = <em style="color:brown">getNumberOfVertices()</em>;
...
}

public static final class <em style="color:blue">Sum </em>{
...
// get the number of vertices
long numVertices = <em style="color:brown">getNumberOfVertices()</em>;
...
}

public static final class <em style="color:blue">Apply</em> {
...
// get the number of vertices
long numVertices = <em style="color:brown">getNumberOfVertices()</em>;
...
}
</code></pre>

As you can see, also in this case, <em>getNumberOfVertices()</em> can be called in all the phases of each superstep.
<p></p>
<p><img src="./images/compare.jpg" align="right"/></p>
<h3>Which model to use??</h3>
<h4>Vertex-centric vs GSA</h4>
<p>By now you would have realized that Gather-Sum-Apply iterations are quite similar to vertex-centric iterations. In fact, <strong>any algorithm which can be expressed as a GSA iteration can also be written in the vertex-centric model</strong>. The messaging phase of the vertex-centric model is equivalent to the Gather and Sum steps of GSA: Gather can be seen as the phase where the messages are produced and Sum as the phase where they are sent to the target vertex. Similarly, the value update phase corresponds to the Apply step.</p>
<p>Some of the difference between the two implementations are: <ul>
<li>Gather phase of GSA parallelizes the computation over the edges, while the messaging phase distributes the computation over the vertices.</li>
<li>GSA works strictly on neighborhoods, while in the vertex-centric model, a vertex can send a message to any vertex, given that it knows its vertex ID.</li>
<li>In the vertex-centric implementation, one can choose the messaging direction.</li></ul>
For a detailed explanation regarding the differences, read <a href="https://ci.apache.org/projects/flink/flink-docs-master/libs/gelly_guide.html#vertex-centric-and-gsa-comparison">here</a>.</p><br>
<p>Finally, we have a complete picture of the iterative models in Gelly. Choose the one most suitable for you and have fun &quot;<em>Gellifying</em>&quot; your iterations! </p>

<p><h4><a style="margin-left: 100px" href="./tutorial7.html"><em><--Previous</em></a><a style="margin-left: 650px" href="#"><em>Done!</em></a></h4></p><br><br>
    </div> <!-- /container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="./dist/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="./assets/js/ie10-viewport-bug-workaround.js"></script>
  </body>
</html>
