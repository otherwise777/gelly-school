<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="./favicon.ico">

    <title>Library Methods</title>

    <!-- Bootstrap core CSS -->
    <link href="./dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="navbar-fixed-top.css" rel="stylesheet">

    <script src="./assets/js/ie-emulation-modes-warning.js"></script>


  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Gelly</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="./index.html">Home</a></li>
            <li><a href="https://github.com/apache/flink/tree/master/flink-staging/flink-gelly" title="Gelly's SourceCode">GitHub</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Tutorials<span class="caret"></span></a>
              <ul class="dropdown-menu">
			  	<li><a href="./tutorial0.html">Tutorial0: Introduction to Gelly</a></li>
				<li><a href="./tutorial1.html">Tutorial1: Create a graph and run a library method</a></li>
				<li><a href="./tutorial2.html">Tutorial2: Know your Graph</a></li>
				<li><a href="./tutorial3.html">Tutorial3: Simple Transformations</a></li>
				<li><a href="./tutorial4.html">Tutorial4: Advanced Transformations</a></li>
				<li><a href="./tutorial5.html">Tutorial5: Neighborhood methods</a></li>
				<li><a href="./tutorial6.html">Tutorial6: Implement a graph validator</a></li>
				<li><a href="./tutorial7.html">Tutorial7: Vertex-centric iterations</a></li>
				<li><a href="./tutorial8.html">Tutorial8: Gather-sum-apply iterations</a></li>
              </ul>
            </li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>


    <!-- Begin page content -->
    <div class="container">
	
      <div class="page-header">
        <h1>Library methods</h1>
      </div>
	  
	  <p>Gelly provides a collection of graph algorithms for easily analysing large-scale Graphs. So far, the following library methods are implemented:
	  <ul>
	  <li>Simple Community Detection</li>
	  <li>Label Propagation</li>
	  <li>PageRank</li>
	  <li>Connected Components</li>
	  <li>Single-Source Shortest Paths</li>
      </ul></p>
	  <br>
	  
	 <div class="alert alert-success" role="alert" >
	  <h2>Simple Community Detection</h2><br>
	  <h4>Overview</h4>
	  <p style="color:black">Graphs in real systems are not regular or random. Their vertices tend to form clusters or communities with high density of within-group edges and lower density of between-group edges. This library method allows to detect community structures. It's applications range from social networks to metabolic networks.</p><br>
	  <h4>Details</h4>
	  <p style="color:black">The implementation is based on vertex-centric iterations.  Initially, each vertex is assigned a tuple formed of its own id along with a score equal to 1.0, as value. During each iteration, the vertices propagate their labels and max scores, each time adopting the label with the highest score from the list of received messages. The chosen label is afterwards re-scored using the fraction delta/the superstep number so that the score associated with a label decreases as it traverses from the origin. The value delta determines how far a label can spread and is passed as a parameter. It's default value is set to 0.5.<br>
	  The algorithm converges when vertices no longer update their value or when the maximum number of iterations is reached.</p><br>
	  <h4>How to run</h4>
	  <p style="color:black">Call the run method on your input graph passing as parameters the number of iterations and delta as follows:<br>
	  <code>graph.run(new CommunityDetectionAlgorithm(maxIterations, delta));</code><br><br>
	  Output is a graph with each Vertex having as value the ID of the community it converged to.</p><br>
	  <a href="http://arxiv.org/pdf/0808.2633.pdf">Reference paper</a>
	  </div>
	  
	  <br>
	  
	 <div class="alert alert-success" role="alert" >
	  <h2>Label Propagation</h2><br>
	  <h4>Overview</h4>
	  <p style="color:black">This is an implementation of an algorithm for finding communities by propagating labels. Unlike the previously described community detection algorithm, in this case, there are no scores associated to the labels.</p><br>
	  <h4>Details</h4>
	  <p style="color:black">Initially, each vertex is assigned its id as its label. Labels are represented by Longs and in order to break ties, it is assumed that there is a total ordering among them.<br>
	  This implementation uses the vertex-centric iterative model. Vertices propagate their labels to their neighbors during each Messaging phase and adopt the most frequent label among their neighbors in the Update phase. The algorithm converges when no vertex changes value or the maximum number of iterations have been reached.</p><br>
	  <h4>How to run</h4>
	  <p style="color:black">Call the run method on your input graph passing as parameters the number of iterations and delta as follows:<br>
	  <code>graph.run(new LabelPropagationAlgorithm<Long>(maxIterations));</code><br><br>
	  Output is a graph with each Vertex having as value the ID of the community it converged to.</p>
	  </div>

	  <br>
	  

	 <div class="alert alert-success" role="alert" >
	  <h2>PageRank</h2><br>
	  <h4>Overview</h4>
	  <p style="color:black">Page Rank is a numeric value that represents the importance of a page on the web and is used by Google to rank websites in their search engine results.<br>The output of the PageRank algorithm is a probability distribution used to represent the likelihood that a person randomly clicking on links will arrive at any particular page. However, the mathematics of the algorithm are general, making it applicable to graphs or networks in different domains.</p><br>
	  <h4>Details</h4>
	  <p style="color:black">During the Messaging phase, of each iteration, the rank of a vertex is distributed among all target vertices according to the transition probability, which is associated with an edge as the edge value. In the Update phase, first the partial ranks from all incoming messages are summed up and then the dampening formula is applied to calculate the new rank and store it as vertex value.<br>
	  The dampening factor, to be passed as parameter, is the probability, at any step, that a surfer will continue clicking on links randomly. It is generally assumed to be around 0.85. The algorithm converges when no vertex changes value or the maximum number of iterations have been reached.</p><br>
	  <h4>How to run</h4>
	  <p style="color:black">Call the run method on a weighted graph passing as parameters the dampening factor and maximum number of iterations.<br>
	  <code>graph.run(new PageRankAlgorithm<Long>(DAMPENING_FACTOR, maxIterations));</code><br><br>
	  Output is a graph with each Vertex having as value its associated PageRank.</p>
	  </div>
	  
	  <br>
	  
	  <div class="alert alert-success" role="alert" >
	  <h2>Connected Components</h2><br>
	  <h4>Overview</h4>
	  <p style="color:black">A connected component of an undirected graph is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph.</p><br>
	  <h4>Details</h4>
	  <p style="color:black">Initially, each vertex has its own ID as a value (it is its own component). Vertices propagate their current component ID in iterations, each time adopting a new value from the received neighbor IDs, provided that the value is smaller than the current minimum. To this end, in the Messaging phase, the minimum ID associated with a given vertex is distributed among all the target vertices while in the Update phase, the value of a vertex is updated by picking the minimum neighbor ID out of all the incoming messages. The computation terminates after the specified maximum number of supersteps or when the vertex states stop changing.</p><br>
	  <h4>How to run</h4>
	  <p style="color:black">
	  <code>graph.run(new ConnectedComponentsAlgorithm(maxIterations));</code><br><br>
	  Output is a graph with each Vertex having as value the minimum ID among all the connected neighbors.</p>
	  </div>

	  <br>

	 <div class="alert alert-success" role="alert" >
	  <h2>Single-Source Shortest Paths</h2><br>
	  <h4>Overview</h4>
	  <p style="color:black">This algorithm is used to find a path between two vertices in a graph such that the sum of the weights of its constituent edges is minimized.</p><br>
	  <h4>Details</h4>
	  <p style="color:black">In each superstep, each vertex sends a candidate distance message to all its neighbors. The message value is the sum of the current value of the vertex and the edge weight connecting this vertex with its neighbor. Upon receiving candidate distance messages, each vertex calculates the minimum distance and, if a shorter path has been discovered, it updates its value. If a vertex does not change its value during a superstep, then it does not produce messages for its neighbors for the next superstep. The computation terminates after the specified maximum number of supersteps or when there are no value updates.</p><br>
	  <h4>How to run</h4>
	  <p style="color:black">Call the run method on a weighted graph, passing as parameters the ID of the source vertex and maximum number of iterations.<br>
	  <code>graph.run(new SingleSourceShortestPathsAlgorithm<K>(srcVertexId, maxIterations));</code><br><br>
	  Output is a graph with each vertex having as value the minimum distance with respect to the source vertex.</p>
	  </div>

	  <br><br>
	  
    </div> <!-- /container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="./dist/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="./assets/js/ie10-viewport-bug-workaround.js"></script>
  </body>
</html>
