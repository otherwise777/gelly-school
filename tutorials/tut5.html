        <!DOCTYPE html><html>
            <head>
               <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
                <title>Tutorial5</title>
                <link rel="stylesheet" type="text/css" href="styles.css">
            </head>
        <body>
                <div id="wrapper">

                <div id="header">
                <img src="./images/logo_color_50.png">
                    <h1>Learn you some Gelly</h1></img>
                 </div> <!-- header -->

		<div id="menu">
			<ul id="list-nav">
				<li class="first"><a href="http://gellyschool.com"
					title="Gelly Home">HomePage</a></li>
				<li><a href="./tut1.html"
					title="Load public data and create a graph">Tutorial#1</a></li>
				<li><a href="./tut2.html" title="Know your graph">Tutorial#2</a></li>
				<li><a href="./tut3.html" title="	Simple transformations">Tutorial#3</a></li>
				<li><a href="./tut4.html" title="Advanced transofrmations">Tutorial#4</a></li>
				<li><a href="./tut5.html" title="Neighborhood methods">Tutorial#5</a></li>
				<li><a href="./tut6.html" title="Implement a graph validator">Tutorial#6</a></li>
				<li><a href="./tut7.html" title="Vertex-centric iterations">Tutorial#7</a></li>
				<li><a href="./tut8.html" title="Gather-sum-apply iterations">Tutorial#8</a></li>
				<li class="last"><a
					href="https://github.com/apache/flink/tree/master/flink-staging/flink-gelly"
					title="Gelly on GitHub">SourceCode</a></li>
				</a>
				</li>
			</ul>
		</div>
		<!-- menu -->
                <div id="container">
				<h2>Tutorial #5: Neighborhood methods</h2>
<h3>Socialize with your neighbors</h3>
<p>This article is a step by step guide to gain familiarity with the neighborhood methods of Gelly. We will study them using the problem of calculating Local Clustering Coefficient as example. In particular, we will get acquaintance with the <strong><em>reduceOnEdges()</em></strong> and <strong><em>reduceOnNeighbors()</em></strong> aggregation methods. Moreover, we will also get to meet our friend from the last tutorial, <strong><em>joinWithVertices()</em></strong>, again.</p>
<br>
<h4>Tools at hand</h4>
<p style="margin-top: -1em">Neighborhood methods allow vertices to perform an aggregation on their first-hop neighborhood. <em>reduceOnEdges()</em> can be used to compute an aggregation on the values of the neighboring edges of a vertex and <em>reduceOnNeighbors()</em> can be used to compute an aggregation on the values of the neighboring vertices.
The neighborhood scope is defined by the <em>EdgeDirection</em> parameter, which takes the values <em>IN</em>, <em>OUT</em> or <em>ALL</em>. IN will gather all in-coming edges (neighbors) of a vertex, <em>OUT</em> will gather all out-going edges (neighbors), while <em>ALL</em> will gather all edges (neighbors).</p> <br>
<h4>What is this Local Clustering Coefficient?</h4>
<p style="margin-top: -1em">A <a href="https://en.wikipedia.org/wiki/Clustering_coefficient">clustering coefficient</a> tells us the degree to which nodes in a graph tend to cluster together. There are two versions of it: local and global. The global coefficient gives an overall indication of the clustering in the whole network, whereas the local one gives an insight into the local density. For a node, this is the number of links present over the total number of possible links between it's neighbors. Thus, the local clustering coefficient quantifies how close the node's neighbors are to being a complete graph. For a directed graph this is given by....</p>
<p><strong>drawing 5.1 with formula from wiki</strong> (can only upload from link)</p>
<br>
<h4>Practical overview</h4>
<p style="margin-top: -1em">We are using the local clustering coefficient calculation as example or this tutorial because as seen from the formula above, each node needs to know the &quot;friendship status&quot; of its neighborhood i.e. for each of it's neighbors, it needs to keep track of how well connected that neighbor is to it's other neighbors. As we will see, this information can be easily retrieved by invoking the aforementioned reduce methods.</p>
<p>To play around with the algorithm, any graph data set will do given that it is read in a manner appropriate for calculating our coefficients. In short, all we need is information regarding directed edges (source and target nodes). Hence, if the input data set has also edge values, that information can be ignored. </p>
<br>
<h5>Graph creation</h5>
<p style="margin-top: -1em">For graph creation in Gelly, refer to <a href="./tut2.html">tutorial#1</a>. To avoid repetitions, only code is given below; redundant explanation regarding the first part will be skipped and we will jump straight to the neighborhood methods.
The only point worth mentioning here from the implementation point of view, is that the vertex value has been allocated as a <em>HashMap&lt;String,HashSet<Long>&gt;</em>. Keys are String objects, named <em>&quot;incoming&quot;</em> and <em>&quot;outgoing&quot;</em>. For each vertex, the incoming key is associated with a Set of neighbors pointing to the node, whereas the outgoing key is associated with a Set of neighbors the node is itself pointing to.</p>
<pre><code>    //read the Edge DataSet from the input file
    DataSet&lt;Edge&lt;Long, NullValue&gt;&gt; links =  env.readCsvFile(edgeInputPath)
            .fieldDelimiter(&quot;\t&quot;)
            .lineDelimiter(&quot;\n&quot;)
            .types(Long.class, Long.class)
            .map(new MapFunction&lt;Tuple2&lt;Long, Long&gt;, Edge&lt;Long, NullValue&gt;&gt;() {
                public Edge&lt;Long, NullValue&gt; map(Tuple2&lt;Long, Long&gt; value) {
                    return new Edge&lt;Long, NullValue&gt;(value.f0, value.f1,
                            NullValue.getInstance());
                    }
                });

    //create a graph initializing vertex values
    Graph&lt;Long, HashMap&lt;String,HashSet&lt;Long&gt;&gt;, NullValue&gt; graph = 
	      Graph.fromDataSet(links, new MapFunction&lt;Long, HashMap&lt;String,HashSet&lt;Long&gt;&gt;&gt;() {

        public HashMap&lt;String, HashSet&lt;Long&gt;&gt; map(Long value) throws Exception {
            return  new HashMap&lt;String,HashSet&lt;Long&gt;&gt;();
        }
    }, env);
</code></pre>
<br><br>
<h5>Gather neighboorhood info</h5>
<p style="margin-top: -1em">Now that we have a graph, we will use the <strong><em>groupReduceOnEdges()</em></strong> method with a user-defined function acting upon each of the resulting neighborhoods.
A question that may arise here is why did we select <em>groupReduceOnEdges()</em> and not <em>reduceOnEdges()</em>. The reason is that when the aggregation function is not associative and commutative or when it is desirable to return more than one values per vertex, the more general <em>groupReduceOnEdges()</em> and <em>groupReduceOnNeighbors()</em> methods can be used. These methods return zero, one or more values per vertex and provide access to the whole neighborhood.
The following code will collect the out-edges and in-edges for each vertex and apply the <em>NeighborsSet()</em> function on each of the resulting neighborhoods.
In order to decide whether to put the neighbor in the incoming Set or the outgoing Set, a check is made on the target vertex of the edge under consideration. If the target vertex is the node itself, it means that the edge is an incoming one.</p>
<pre><code>//for each vertex save its incoming and outgoing neighbors
DataSet&lt;Tuple2&lt;Long,HashMap&lt;String,HashSet&lt;Long&gt;&gt;&gt;&gt; neighbSet = 
   graph.groupReduceOnEdges(new NeighborsSet(),EdgeDirection.ALL);


@SuppressWarnings(&quot;serial&quot;)
static final class NeighborsSet implements EdgesFunction
         &lt;Long,NullValue,Tuple2&lt;Long,HashMap&lt;String,HashSet&lt;Long&gt;&gt;&gt;&gt; {


    @Override
    public void iterateEdges(
            Iterable&lt;Tuple2&lt;Long, Edge&lt;Long, NullValue&gt;&gt;&gt; edges,
            Collector&lt;Tuple2&lt;Long, HashMap&lt;String,HashSet&lt;Long&gt;&gt;&gt;&gt; out) throws Exception {

        Long vertexId = null;
        HashMap&lt;String,HashSet&lt;Long&gt;&gt; neighbList= new HashMap&lt;String,HashSet&lt;Long&gt;&gt;();
        neighbList.put(&quot;incoming&quot;, new HashSet&lt;Long&gt;());
        neighbList.put(&quot;outgoing&quot;, new HashSet&lt;Long&gt;());


        for(Tuple2&lt;Long, Edge&lt;Long, NullValue&gt;&gt; e: edges){

            vertexId= e.f0;
            if(e.f1.getTarget().equals(vertexId))
                neighbList.get(&quot;incoming&quot;).add(e.f1.getSource());
            else
                neighbList.get(&quot;outgoing&quot;).add(e.f1.getTarget());


        }
        out.collect(new Tuple2&lt;Long, HashMap&lt;String,HashSet&lt;Long&gt;&gt;&gt;(vertexId,neighbList));

    }

}
</code></pre>
<br>
<h5>Using the gathered info</h5>
<p style="margin-top: -1em">First, we will update the values of the vertices in our graph by performing  a join with the Data set <em>&lt;vertexId, HashMap of neighbors&gt;</em> obtained in the previous step. Then we will call the <strong><em>groupReduceOnNeighbors()</em></strong> with the ad-hoc <em>CoefficientCalc()</em> function. The latter is where the actual formula for calculating the local coefficient is implemented. For each vertex, the for loop as in the code below, is used to check whether a link exists between the neighbor in the current iteration of the loop and the other neighbors in common to the two nodes. The final data set will consist of <em>&lt;vertexId,coefficient&gt;</em>.
<strong>...sample calculation drawing 5.2....</strong></p>
<pre><code>    //perform a join to update the vertex values with neighbor's info
    Graph&lt;Long, HashMap&lt;String,HashSet&lt;Long&gt;&gt;, NullValue&gt; graph2 = graph.joinWithVertices(neighbSet,
            new MapFunction&lt;Tuple2&lt;HashMap&lt;String,HashSet&lt;Long&gt;&gt;,HashMap&lt;String,HashSet&lt;Long&gt;&gt;&gt;,
			     HashMap&lt;String,HashSet&lt;Long&gt;&gt;&gt;(){
                @Override
                public HashMap&lt;String,HashSet&lt;Long&gt;&gt; map(Tuple2&lt;HashMap&lt;String,HashSet&lt;Long&gt;&gt;,
				        HashMap&lt;String,HashSet&lt;Long&gt;&gt;&gt; value) throws Exception {
                    return value.f1;
                }});

    //calculate the local coeff for each vertex
    DataSet&lt;Tuple2&lt;Long,Double&gt;&gt; coefficients = 
	    graph2.groupReduceOnNeighbors(new CoefficientCalc(),EdgeDirection.ALL);

    coefficients.print();

}


@SuppressWarnings(&quot;serial&quot;)
static class CoefficientCalc implements NeighborsFunctionWithVertexValue
&lt;Long,HashMap&lt;String,HashSet&lt;Long&gt;&gt;,NullValue, Tuple2&lt;Long,Double&gt;&gt; {

    @Override
    public void iterateNeighbors(
            Vertex&lt;Long, HashMap&lt;String,HashSet&lt;Long&gt;&gt;&gt; vertex,
            Iterable&lt;Tuple2&lt;Edge&lt;Long, NullValue&gt;, Vertex&lt;Long, HashMap&lt;String,HashSet&lt;Long&gt;&gt;&gt;&gt;&gt; neighbors,
            Collector&lt;Tuple2&lt;Long, Double&gt;&gt; out) throws Exception {

        double coefficient;
        double numerator = 0;

        HashSet&lt;Long&gt; neighbCount= new HashSet&lt;Long&gt;();
        neighbCount.addAll(vertex.f1.get(&quot;incoming&quot;));
        neighbCount.addAll(vertex.f1.get(&quot;outgoing&quot;));

        //Set has been used to remove duplicate neighbors: 
        //those present both in incoming and outgoing are to be counted only once
        int denominator =neighbCount.size()*(neighbCount.size()-1);

        //to store links amongst neighbors
        HashSet&lt;String&gt; links = new HashSet&lt;String&gt;();

        for(Tuple2&lt;Edge&lt;Long,NullValue&gt;,Vertex&lt;Long,HashMap&lt;String,HashSet&lt;Long&gt;&gt;&gt;&gt; n : neighbors){
            for(Long id : n.f1.getValue().get(&quot;incoming&quot;)){
                if(vertex.f1.get(&quot;incoming&quot;).contains(id)||vertex.f1.get(&quot;outgoing&quot;).contains(id)){
                    links.add(&quot;&quot;+id+&quot; &quot;+n.f1.f0);
                }
            }
            for(Long id : n.f1.getValue().get(&quot;outgoing&quot;)){
                if(vertex.f1.get(&quot;incoming&quot;).contains(id)||vertex.f1.get(&quot;outgoing&quot;).contains(id)){
                    links.add(&quot;&quot;+n.f1.f0+&quot; &quot;+id);
                }
            }
        }

        //number of connections amongst neighbors
        numerator=links.size();

        if(denominator&lt;1)
            coefficient=0.0;
        else
            coefficient=(double)numerator/(double)denominator;

        out.collect(new Tuple2&lt;Long,Double&gt;(vertex.f0,coefficient));

    }}
</code></pre>
<br>
<h5>And we are done!</h5>
<p style="margin-top: -1em">That was our quick introduction to Gelly's neighborhood methods. Play with them and take advantage of your neighborhoods to the max!</p>
<p>Following is the link to the full code of the clustering coefficient example we have discussed in this tutorial:<br><a href="https://github.com/vasia/gelly-school/blob/gelly-tutorials/src/main/java/flink/gelly/school/LocalClusteringCoefficient.java">LCC Solution</a></p>

                </div><!-- content -->
                <div id="footer">
                    <p>This site is maintained by  <a href="https://github.com/vasia">Vasia</a></p>
                </div> <!-- footer -->
            </div> <!-- wrapper -->


        </body>
        </html>