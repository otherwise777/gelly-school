<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="./favicon.ico">

    <title>Tutorial7</title>

    <!-- Bootstrap core CSS -->
    <link href="./dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="navbar-fixed-top.css" rel="stylesheet">

    <script src="./assets/js/ie-emulation-modes-warning.js"></script>

  </head>

  <body>

<!-- Fixed navbar -->
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="./index.html">Gellyschool</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Tutorials<span class="caret"></span></a>
              <ul class="dropdown-menu">
                                <li><a href="./tutorial0.html">Tutorial0: Introduction to Gelly</a></li>
                                <li><a href="./tutorial1.html">Tutorial1: Create a graph and run a library method</a></li>
                                <li><a href="./tutorial2.html">Tutorial2: Know your Graph</a></li>
                                <li><a href="./tutorial3.html">Tutorial3: Simple Transformations</a></li>
                                <li><a href="./tutorial4.html">Tutorial4: Advanced Transformations</a></li>
                                <li><a href="./tutorial5.html">Tutorial5: Neighborhood methods</a></li>
                                <li><a href="./tutorial6.html">Tutorial6: Implement a graph validator</a></li>
                                <li><a href="./tutorial7.html">Tutorial7: Vertex-centric iterations</a></li>
                                <li><a href="./tutorial8.html">Tutorial8: Gather-sum-apply iterations</a></li>
              </ul>
            </li>
            <li><a href="https://github.com/vasia/gelly-school">Solutions</a></li>
            <li><a href="https://ci.apache.org/projects/flink/flink-docs-master/libs/gelly_guide.html">Gelly Docs</a></li>
            <li><a href="./library.html" title="Gelly's Library Methods">Library Methods</a></li>
            <li><a href="./about.html">About</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <!-- Begin page content -->
    <div class="container">
      <div class="page-header">
        <h1>Iterative Graph Processing</h1>
      </div>
<h2>Vertex-centric iterations</h2>
<p>In this tutorial, we are going to discuss the <strong>vertex-centric</strong> iterative model provided by Gelly.</p>
<p>In the <em>vertex-centric model</em> computations proceed in synchronized iteration steps, called <em>supersteps</em>. In each superstep, a vertex produces messages for other vertices and updates its value based on the messages it receives. To use vertex-centric iterations in Gelly, you only needs to define two functions that determine the behaviour of a Vertex in each superstep:</p>
<ul>
<li><strong><em>MessagingFunction()</em></strong>: produces the messages that a vertex will send to other vertices.</li>
<li><strong><em>VertexUpdateFunction()</em></strong>: updates the vertex value using the received messages.</li>
</ul><br>
The above two functions and the maximum number of iterations to run, are given as parameters to Gellyâ€™s <strong><em>runVertexCentricIteration()</em></strong>. This method will execute the vertex-centric iteration on the input Graph and return a new Graph, with updated vertex values.</p>
<p>Let's understand this better with an example. We are going to consider a simplified implementation of the <a href="https://en.wikipedia.org/wiki/PageRank"><strong>PageRank</strong></a> algorithm.</p><br>
<h4>A few words about PageRank</h4>
<p><em>PageRank</em> is a numeric value that represents the importance of a page on the web and is used by Google to rank websites in their search engine results.
In short, the output of the algorithm is a probability distribution used to represent the likelihood that a person randomly clicking on links will arrive at any particular page. For details, have a good read of the <a href="https://en.wikipedia.org/wiki/PageRank">wikipedia</a> article.</p><br>
<h4>Hands on</h4>
<p>In each superstep:<ul>
<li> Each vertex sends a rank message to all of its neighbors, distributing the rank according to edge weights.</li><br>
<pre><code><em style="color:green">
/**
 * Distributes the rank of a vertex among all target vertices according to
 * the transition probability, which is associated with an edge as the edge
 * value.
 */</em>
@SuppressWarnings(&quot;serial&quot;)
public static final class RankMessenger&lt;K&gt; extends <strong>MessagingFunction</strong>&lt;K, Double, Double, Double&gt; {

    private final long numVertices;

    public RankMessenger(long numberOfVertices) {
        this.numVertices = numberOfVertices;
    }

    @Override
    public void <em style="color:blue">sendMessages</em>(Vertex&lt;K, Double&gt; vertex) {
        if (getSuperstepNumber() == 1) {
            <em style="color:green">// initialize vertex values during the first superstep</em>
            vertex.setValue(new Double(1.0 / numVertices));
        }

        for (Edge&lt;K, Double&gt; edge : getEdges()) {
            sendMessageTo(edge.getTarget(), vertex.getValue() * edge.getValue());
        }
    }
}
</code></pre><br>

<li> Upon receiving the rank messages, each Vertex sums the partial ranks, calculates its new ranking according to the dampening formula, and updates its own PageRank value.</li></ul>
<pre><code><em style="color:green">
/**
 * Function that updates the rank of a vertex by summing up the partial
 * ranks from all incoming messages and then applying the dampening formula.
 */</em>
@SuppressWarnings(&quot;serial&quot;)
public static final class VertexRankUpdater&lt;K&gt; extends <strong>VertexUpdateFunction</strong>&lt;K, Double, Double&gt; {

    private final double beta;
    private final long numVertices;

    public VertexRankUpdater(double beta, long numberOfVertices) {
        this.beta = beta;
        this.numVertices = numberOfVertices;
    }

    @Override
    public void <em style="color:blue">updateVertex</em>(Vertex&lt;K, Double&gt; vertex, MessageIterator&lt;Double&gt; inMessages) {
        double rankSum = 0.0;
        <em style="color:green">// sum the incoming partial ranks</em>
        for (double msg : inMessages) {
            rankSum += msg;
        }
         <em style="color:green">// apply the dampening formula</em>
        double newRank = (beta * rankSum) + (1 - beta) / numVertices;
		
	<em style="color:green">// update Vertex value</em>
        setNewVertexValue(newRank);
    }
}
</code></pre>
<br>
 The algorithm converges when there are no value updates. If the value of a Vertex does not change during a superstep, it will not send any messages in the superstep. This allows to do incremental updates to the changing parts of the graph, while leaving steady parts untouched. The computation terminates after a specified maximum number of supersteps or when convergence is reached.</p>
<p><img src="./images/iter1.jpg"/></p><br>
<br>
<p>The output is a DataSet of vertices, where the Vertex value is the rank of the given Vertex.
You can find the full implementation <strong><a href="https://github.com/apache/flink/blob/master/flink-staging/flink-gelly/src/main/java/org/apache/flink/graph/library/PageRankAlgorithm.java">here</a></strong>.
<br>
It is to be noted that in our simple implementation, it is assumed that all the nodes have at least an incoming and an outgoing edge. Why this? Well, because as you can notice, a node updates its rank value according to the dampening formula, only when it receives a message from a neighbor. So if a node never receives a message, it's final rank will not be compliant with the theoretical value.<br><br>
If we run the PageRankAlgorithm using the Graph obtained from the twitter data set, then we obtain the output as shown in the figure below: </p>
<p><img src="./images/screenshot7_1.PNG" /></p><br>
<h4>Configuring a Vertex-Centric Iteration</h4>
<p>A vertex-centric iteration can be configured using a <strong><em>VertexCentricConfiguration</em></strong> object. Currently, the following parameters can be specified:<em> Name,Parallelism, Aggregators, Broadcast Variables, Number of Vertices, Degrees, Messaging Direction</em>. You can find more details regarding these parameters at this <a href="https://ci.apache.org/projects/flink/flink-docs-master/libs/gelly_guide.html#configuring-a-vertex-centric-iteration">link</a>.<br>
<p>For example, if we want to access the total number of vertices and the degree information of a node within an iteration, then we need to set these options to true and pass the updated parameter to the vertex-centric iteration. This allows us to retrieve the required information both within the VertexUpdateFunction and the MessagingFunction as shown below.</p>

<pre><code><em style="color:green">// configure the iteration</em>
VertexCentricConfiguration parameters = new VertexCentricConfiguration();

<em style="color:green">// set the number of vertices option to true</em>
parameters.<em style="color:blue">setOptNumVertices</em>(true);

<em style="color:green">// set the degree option to true</em>
parameters.<em style="color:blue">setOptDegrees</em>(true);

<em style="color:green">// run the vertex-centric iteration, also passing the configuration parameters</em>
Graph&lt;Long, Double, Double&gt; result =
        graph.<em style="color:blue">runVertexCentricIteration</em>(
        new VertexUpdater(), new Messenger(), maxIterations, parameters);
		
<em style="color:green">// user-defined functions</em>
public static final class VertexUpdater {
       <em style="color:green">// get the number of vertices</em>
	long numVertices = <em style="color:brown">getNumberOfVertices()</em>;
	<em style="color:green">// retrieve the vertex out-degree</em>
	outDegree = <em style="color:brown">getOutDegree()</em>;
	.....
}


}
</code></pre>
<br><br>
<h4>What's next?</h4>
<p> To not overload you with information, we will consider the Gather-sum-apply iterative model in the next tutorial. But before moving on, try your hand at the vertex-centric iterations.</p>

<p><h4><a style="margin-left: 100px" href="./tutorial6.html"><em><--Previous</em></a> <a style="margin-left: 650px" href="./tutorial8.html"><em>Next--></em></a></h4></p>
<br><br>
    </div> <!-- /container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="./dist/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="./assets/js/ie10-viewport-bug-workaround.js"></script>
  </body>
</html>
